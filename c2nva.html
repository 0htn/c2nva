theme: jekyll-theme-modernist
<!DOCTYPE html>
<html>
<head>
  <title>Canvas with Multiple Sheets and Tools</title>
  <style>
    /* CSS styles for the canvas, sheets, and tools */
    .canvas-container {
      display: flex;

    }
    .sheets-container {
      width: 150px;
      border: 1px solid #ccc;
      padding: 10px;
    }
    .sheet {
      border: 1px solid #000;
      margin-bottom: 5px;
      padding: 5px;
      cursor: pointer;
    }
    .canvas {
      border: 1px solid #000;
      margin-left: 20px;
    }
    .tools {
      margin-left: 20px;
    }
    .saved-sheets-container {
      margin-top: 20px;
    }
    .saved-sheet {
      border: 1px solid #000;
      margin-bottom: 5px;
      padding: 5px;
      cursor: pointer;
    }

  </style>
</head>
<body>
  <div class="canvas-container">
    <div class="sheets-container" id="sheetsContainer">
      <!-- Small Sheets will be added here -->
    </div>
    <div class="canvas">
      <canvas id="mainCanvas" width="500" height="500"></canvas>
    </div>
    <div class="tools">
      <button id="penTool">Pen</button>
<button id="fillBackgroundTool">Fill Background</button>
<button id="drawLineTool">Fill</button>
<select id="penStyle">
  <option value="normal">Normal</option>
  <option value="dotted">Dotted</option>
  <option value="dashed">Dashed</option>
</select>
      <button id="highlighterTool">Highlighter</button>
      <button id="eraserTool">Eraser</button>
<select id="shapeType">
  <option value="rectangle">Shapes</option>
  <option value="rectangle">Rectangle</option>
  <option value="circle">Circle</option>
  <option value="square">Square</option>
  <option value="triangle">Triangle</option>
  <option value="hexagon">Hexagon</option>
</select>
      <input type="range" id="penSize" min="1" max="20" value="5">
      <input type="color" id="colorPicker" value="#000000">
      <button id="saveButton">Save Drawing</button>
      <button id="undoButton">Undo</button>
      <button id="redoButton">Redo</button>
      <button id="deleteButton">Delete Selected Sheet</button>
<label for="opacityRange">Opacity:</label>
  <input type="range" id="opacityRange" min="0" max="1" step="0.1" value="1">
 <button id="cropButton">WaterPen</button>
    </div>
  </div>

<input type="file" id="fileInput">
  <div class="saved-sheets-container">
    <!-- Saved Sheets will be added here -->
  </div>
  <script>
    let sheetCounter = 1;
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let selectedColor = '#000000'; // Initial color is black
    let selectedTool = 'pen';
    let editingSavedSheetIndex = -1;
    let undoStack = [];
    let redoStack = [];

    const canvasArray = [];
    const ctxArray = [];

    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');

    // Function to create a new sheet and switch to it
    function addNewSheet() {
      const newSheet = document.createElement('div');
      newSheet.classList.add('sheet');
      newSheet.textContent = sheetCounter;
      newSheet.addEventListener('click', () => switchToSheet(newSheet));
      
      document.getElementById('sheetsContainer').appendChild(newSheet);
      sheetCounter++;
      switchToSheet(newSheet); // Automatically switch to the new sheet
    }

    // Function to switch between sheets
    function switchToSheet(selectedSheet) {
      const canvas = document.getElementById('mainCanvas');
      const ctx = canvas.getContext('2d');

      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Highlight the selected sheet
      const sheets = document.querySelectorAll('.sheet');
      sheets.forEach((sheet) => {
        sheet.style.backgroundColor = 'transparent';
      });
      selectedSheet.style.backgroundColor = 'lightgray';

      if (canvasArray.length > 0) {
        const selectedCanvas = canvasArray[selectedSheet.textContent - 1];
        canvas.getContext('2d').drawImage(selectedCanvas, 0, 0);
      }
    }

    canvas.addEventListener('mousedown', (e) => {
      if (editingSavedSheetIndex === -1) {
        isDrawing = true;
        [lastX, lastY] = [e.clientX - canvas.getBoundingClientRect().left, e.clientY - canvas.getBoundingClientRect().top];
      }
    });

    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
      editingSavedSheetIndex = -1;
      undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
      redoStack.length = 0; // Clear the redo stack when a new action is performed
    });
    canvas.addEventListener('mouseout', () => {
      isDrawing = false;
      editingSavedSheetIndex = -1;
    });

    function draw(e) {
      if (!isDrawing && editingSavedSheetIndex === -1) return;
      ctx.strokeStyle = selectedColor;
      ctx.lineWidth = document.getElementById('penSize').value;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      [lastX, lastY] = [e.clientX - canvas.getBoundingClientRect().left, e.clientY - canvas.getBoundingClientRect().top];
      ctx.lineTo(lastX, lastY);
      ctx.stroke();
    }

    // Tool selection
    document.getElementById('penTool').addEventListener('click', () => {
      selectedTool = 'pen';
      ctx.globalCompositeOperation = 'source-over'; // Default drawing mode
    });

    document.getElementById('highlighterTool').addEventListener('click', () => {
      selectedTool = 'highlighter';
      ctx.globalCompositeOperation = 'lighter'; // For highlighting effect
    });

    document.getElementById('eraserTool').addEventListener('click', () => {
      selectedTool = 'eraser';
      ctx.globalCompositeOperation = 'destination-out'; // For erasing
    });

    // Color picker
    const colorPicker = document.getElementById('colorPicker');
    colorPicker.addEventListener('input', (e) => {
      selectedColor = e.target.value;
    });

    // Save the drawing
    document.getElementById('saveButton').addEventListener('click', () => {
      const newCanvas = document.createElement('canvas');
      newCanvas.width = canvas.width;
      newCanvas.height = canvas.height;
      const newCtx = newCanvas.getContext('2d');
      newCtx.drawImage(canvas, 0, 0);

      canvasArray.push(newCanvas);
      ctxArray.push(newCtx);

      document.body.appendChild(newCanvas);
      addNewSheet();
    });

    // Undo action
    document.getElementById('undoButton').addEventListener('click', () => {
      if (undoStack.length > 0) {
        redoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        ctx.putImageData(undoStack.pop(), 0, 0);
      }
    });

    // Redo action
    document.getElementById('redoButton').addEventListener('click', () => {
      if (redoStack.length > 0) {
        undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        ctx.putImageData(redoStack.pop(), 0, 0);
      }
    });

function deleteSelectedSheet() {
  const selectedSheet = document.querySelector('.sheet[style*="background-color: lightgray"]');

  if (selectedSheet) {
    const sheetIndex = Array.from(selectedSheet.parentNode.children).indexOf(selectedSheet);

    // Get the selected sheet number before removing it
    const selectedSheetNumber = selectedSheet.textContent;

    // Remove the selected sheet element
    selectedSheet.remove();

    // Clear the canvas
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Create a new sheet for saving the drawing and set its content to the deleted sheet number
    addNewSheet();
    const newSheet = document.querySelector('.sheet:last-child');
    newSheet.textContent = selectedSheetNumber;

    // Save the current drawing to the new sheet
    const newCanvas = canvasArray[sheetIndex]; // Get the canvas from the deleted sheet
    const newCtx = newCanvas.getContext('2d');
    newCtx.drawImage(canvas, 0, 0);

    canvasArray.push(newCanvas);
    ctxArray.push(newCtx);
  }
}
document.getElementById('deleteButton').addEventListener('click', deleteSelectedSheet);

// Add an event listener to the penStyle dropdown
document.getElementById('penStyle').addEventListener('change', function () {
  const selectedStyle = this.value;

  // Set the pen style based on the selected option
  switch (selectedStyle) {
    case 'normal':
      ctx.setLineDash([]);
      break;
    case 'dotted':
      ctx.setLineDash([5, 5]);
      break;
    case 'dashed':
      ctx.setLineDash([10, 5]);
      break;
    default:
      ctx.setLineDash([]);
      break;
  }
});

// Function to set the initial pen style
function setInitialPenStyle() {
  const selectedStyle = document.getElementById('penStyle').value;

  // Set the pen style based on the selected option
  switch (selectedStyle) {
    case 'normal':
      ctx.setLineDash([]);
      break;
    case 'dotted':
      ctx.setLineDash([5, 5]);
      break;
    case 'dashed':
      ctx.setLineDash([10, 5]);
      break;
    default:
      ctx.setLineDash([]);
      break;
  }
}

// Call the function to set the initial pen style
setInitialPenStyle();

// Add an event listener to the shapeType dropdown
document.getElementById('shapeType').addEventListener('change', function () {
  const selectedType = this.value;

  // Set the selected shape type
  selectedTool = selectedType;

  // Reset the canvas line style (in case you were drawing shapes with dashed/dotted lines)
  ctx.setLineDash([]);
});


// Add an event listener to the canvas to handle mouse click events
canvas.addEventListener('click', drawShapeOnClick);

// Function to draw a rectangle at the specified coordinates
function drawRectangleOnClick(x, y) {
  ctx.beginPath();
  ctx.rect(x, y, 50, 30); // Customize the size as needed
  ctx.stroke();
}

// Function to draw a circle at the specified coordinates
function drawCircleOnClick(x, y) {
  ctx.beginPath();
  ctx.arc(x, y, 20, 0, 2 * Math.PI); // Customize the radius as needed
  ctx.stroke();
}

// Function to draw a square at the specified coordinates
function drawSquareOnClick(x, y) {
  ctx.beginPath();
  ctx.rect(x, y, 30, 30); // Customize the size as needed
  ctx.stroke();
}

// Function to draw a triangle at the specified coordinates
function drawTriangleOnClick(x, y) {
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + 40, y + 40);
  ctx.lineTo(x - 40, y + 40);
  ctx.closePath();
  ctx.stroke();
}

// Function to draw a hexagon at the specified coordinates
function drawHexagonOnClick(x, y) {
  ctx.beginPath();
  const sideLength = 25; // Customize the size as needed
  const angle = (Math.PI / 3); // Angle between the sides for a hexagon
  for (let i = 0; i < 6; i++) {
    ctx.lineTo(x + sideLength * Math.cos(i * angle), y + sideLength * Math.sin(i * angle));
  }
  ctx.closePath();
  ctx.stroke();
}

// Function to handle shape drawing based on the selected tool
function drawShapeOnClick(e) {
  const x = e.clientX - canvas.getBoundingClientRect().left;
  const y = e.clientY - canvas.getBoundingClientRect().top;

  if (selectedTool !== 'pen') {
    if (selectedTool === 'rectangle') {
      drawRectangleOnClick(x, y);
    } else if (selectedTool === 'circle') {
      drawCircleOnClick(x, y);
    } else if (selectedTool === 'square') {
      drawSquareOnClick(x, y);
    } else if (selectedTool === 'triangle') {
      drawTriangleOnClick(x, y);
    } else if (selectedTool === 'hexagon') {
      drawHexagonOnClick(x, y);
    }
  }
}

// Event listener for the canvas click event to draw shapes
canvas.addEventListener('click', drawShapeOnClick);
// Add an event listener to the file input
const fileInput = document.getElementById('fileInput');
fileInput.addEventListener('change', handleFileUpload);

function handleFileUpload(e) {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(event) {
      const img = new Image();
      img.onload = function() {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  }
}

 const opacityRange = document.getElementById('opacityRange');
opacityRange.addEventListener('input', () => {
  const opacity = parseFloat(opacityRange.value);
  ctx.globalAlpha = opacity; // Set the global alpha value
});
// Inside your tool selection event listeners
document.getElementById('penTool').addEventListener('click', () => {
  selectedTool = 'pen';
  ctx.globalCompositeOperation = 'source-over';
  // Reset the global alpha to its default value (1)
  ctx.globalAlpha = 1;
});

document.getElementById('highlighterTool').addEventListener('click', () => {
  selectedTool = 'highlighter';
  ctx.globalCompositeOperation = 'lighter';
  // Reset the global alpha to its default value (1)
  ctx.globalAlpha = 1;
});

document.getElementById('eraserTool').addEventListener('click', () => {
  selectedTool = 'eraser';
  ctx.globalCompositeOperation = 'destination-out';
  // Reset the global alpha to its default value (1)
  ctx.globalAlpha = 1;
});

// ...
let isCropping = false;
let cropStartX, cropStartY, cropEndX, cropEndY;

// Function to handle crop selection
function handleCropSelection(e) {
  if (!isCropping && selectedTool === 'crop') {
    isCropping = true;
    [cropStartX, cropStartY] = [e.clientX - canvas.getBoundingClientRect().left, e.clientY - canvas.getBoundingClientRect().top];
  } else if (isCropping) {
    [cropEndX, cropEndY] = [e.clientX - canvas.getBoundingClientRect().left, e.clientY - canvas.getBoundingClientRect().top];
    isCropping = false;
    // Crop and move the selected portion of the drawing
    const selectedImageData = ctx.getImageData(cropStartX, cropStartY, cropEndX - cropStartX, cropEndY - cropStartY);
    ctx.clearRect(cropStartX, cropStartY, cropEndX - cropStartX, cropEndY - cropStartY);
    ctx.putImageData(selectedImageData, cropStartX + 10, cropStartY + 10); // Move it to the new position
  }
}

// Add an event listener for the crop button
document.getElementById('cropButton').addEventListener('click', () => {
  selectedTool = 'crop';
  ctx.globalCompositeOperation = 'source-over';
});

// Add an event listener to the canvas for handling crop selection
canvas.addEventListener('mousedown', handleCropSelection);
canvas.addEventListener('mousemove', handleCropSelection);
canvas.addEventListener('mouseup', handleCropSelection);


//..
document.getElementById('fillBackgroundTool').addEventListener('click', () => {
  selectedTool = 'fillBackground';
});
// Function to fill the background around the drawing
function fillBackground() {
  ctx.globalCompositeOperation = 'source-over'; // Set the drawing mode to overwrite
  ctx.fillStyle = selectedColor; // Set the fill color to the selected color
  ctx.fillRect(0, 0, canvas.width, canvas.height); // Fill the entire canvas with the color
  ctx.globalCompositeOperation = 'source-in'; // Restore the original drawing mode
}

canvas.addEventListener('click', () => {
  if (selectedTool === 'fillBackground') {
    fillBackground();
  }
});

document.getElementById('drawLineTool').addEventListener('click', () => {
  selectedTool = 'drawLine';
});
let isDrawingLine = false;
let lineStartX, lineStartY;

canvas.addEventListener('mousedown', (e) => {
  if (selectedTool === 'drawLine') {
    isDrawingLine = true;
    [lineStartX, lineStartY] = [e.clientX - canvas.getBoundingClientRect().left, e.clientY - canvas.getBoundingClientRect().top];
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (isDrawingLine) {
    const currentX = e.clientX - canvas.getBoundingClientRect().left;
    const currentY = e.clientY - canvas.getBoundingClientRect().top;
    ctx.beginPath();
    ctx.moveTo(lineStartX, lineStartY);
    ctx.lineTo(currentX, currentY);
    ctx.stroke();
  }
});

canvas.addEventListener('mouseup', () => {
  isDrawingLine = false;
});

  </script>
</body>
</html>
